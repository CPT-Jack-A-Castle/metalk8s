#!/bin/bash

set -e
set -u
# The trickery below is to only run `set -o pipefail`, which is a Bash'ism,
# when running in Bash and not some other `sh` which doesn't necessarily
# support `-o pipefail` (though must support `-e` and `-u` per POSIX).
if test -z "$(type -p)"; then set -o pipefail; fi

VERBOSE=${VERBOSE:-0}
LOGFILE=/var/log/metalk8s/bootstrap.log

declare OS

if ! options=$(getopt --options v --long verbose,log-file: -- "$@"); then
    echo 1>&2 "Incorrect arguments provided"
    exit 1
fi
eval set -- "$options"

while true; do
    case "$1" in
        -v|--verbose)
            VERBOSE=1;
            shift;;
        --log-file)
            shift;
            LOGFILE="$1";
            shift;;
        --)
            shift;
            break;;
        *)
            echo 1>&2 "Option parsing failure";
            exit 1;;
    esac
done

TMPFILES=$(mktemp -d)

mkdir -p "$(dirname "${LOGFILE}")"

cat << EOF >> "${LOGFILE}"
--- Bootstrap started on $(date -u -R) ---
EOF

exec > >(tee -ia "${LOGFILE}") 2>&1

determine_os() {
    # We rely on /etc/os-release to discover the OS because its present on all
    # recent Linux distributions
    if [ -f /etc/os-release ]; then
        # shellcheck disable=SC1091
        . /etc/os-release
        OS=$ID
    else
        die "Impossible to determine the OS"
    fi
}

cleanup() {
    rm -rf "${TMPFILES}" || true
}

trap cleanup EXIT

BASE_DIR=$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")

RPM=${RPM:-$(command -v rpm || true)}
DPKG=${DPKG:-$(command -v dpkg || true)}
YUM=${YUM:-$(command -v yum || true)}
APT=${APT:-$(command -v apt || true)}
SYSTEMCTL=${SYSTEMCTL:-$(command -v systemctl)}
SALT_CALL=${SALT_CALL:-salt-call}

declare -a PACKAGES=(
    salt-minion
    genisoimage
)

declare -A GPGCHECK_YUM_REPOSITORIES=(
    [metalk8s-epel]=1
    [metalk8s-kubernetes]=1
    [metalk8s-saltstack]=1
    [metalk8s-scality]=0
)

declare -A GPGCHECK_APT_REPOSITORIES=(
    [metalk8s-bionic]=no
    [metalk8s-bionic-backports]=no
    [metalk8s-bionic-updates]=no
    [metalk8s-kubernetes-xenial]=no
    [metalk8s-salt_ubuntu1804]=no
    [metalk8s-scality]=no
)

run_quiet() {
    local name=$1
    shift 1

    echo -n "> ${name}..."
    local start
    start=$(date +%s)
    set +e
    "$@" > >(tee -ia "${LOGFILE}" > "${TMPFILES}/out") 2>&1
    local RC=$?
    set -e
    local end
    end=$(date +%s)

    local duration=$(( end - start ))

    if [ $RC -eq 0 ]; then
        echo " done [${duration}s]"
    else
        echo " fail [${duration}s]"
        cat >/dev/stderr << EOM

Failure while running step '${name}'

Command: $@

Output:

<< BEGIN >>
EOM
        cat "${TMPFILES}/out" > /dev/stderr

        cat >/dev/stderr << EOM
<< END >>

This script will now exit

EOM

        exit 1
    fi
}

run_verbose() {
    local name=$1
    shift 1

    echo "> ${name}..."
    "$@"
}

run() {
    if [ "$VERBOSE" -eq 1 ]; then
        run_verbose "${@}"
    else
        run_quiet "${@}"
    fi
}

die() {
    echo 1>&2 "$@"
    return 1
}

check_package_manager_yum() {
    test -n "$RPM" || die "rpm not found"
    test -x "$RPM" || die "rpm at '$RPM' is not executable"
    test -n "$YUM" || die "yum not found"
    test -x "$YUM" || die "yum at '$YUM' is not executable"
}

check_package_manager_apt() {
    test -n "$DPKG" || die "dpkg not found"
    test -x "$DPKG" || die "dpkg at '$DPKG' is not executable"
    test -n "$APT" || die "apt not found"
    test -x "$APT" || die "apt '$APT' is not executable"
}

check_dist_centos() {
    check_package_manager_yum
}

check_dist_rhel() {
    check_package_manager_yum
}

check_dist_ubuntu() {
    check_package_manager_apt
}

pre_minion_checks() {
    if declare -f "check_dist_$OS" &> /dev/null; then 
        "check_dist_$OS"
    else
        die "OS $OS not supported"
    fi

    test "x$(whoami)" = "xroot" || die "Script must run as root"
    test -n "$SYSTEMCTL" || die "systemctl not found"
    test -x "$SYSTEMCTL" || die "systemctl at '$SYSTEMCTL' is not executable"
}

disable_salt_minion_service() {
    $SYSTEMCTL disable salt-minion.service 2>/dev/null || true
}

stop_salt_minion_service() {
    $SYSTEMCTL stop salt-minion.service 2>/dev/null || true
}

configure_repositories() {
    case "$OS" in
        centos|rhel)
            configure_yum_repositories
            ;;
        ubuntu)
            configure_apt_repositories
            ;;
        *)
            die "OS $OS not supported";;
    esac
}

configure_yum_repositories() {
    configure_yum_local_repositories

    "$YUM" clean all
}

configure_apt_repositories() {
    configure_apt_local_repositories

    "$APT" clean all
}

configure_yum_local_repositories() {
    for repository in "${!GPGCHECK_YUM_REPOSITORIES[@]}"; do
        configure_yum_local_repository "$repository" \
            "${GPGCHECK_YUM_REPOSITORIES[$repository]}"
    done
}

configure_apt_local_repositories() {
    for repository in "${!GPGCHECK_APT_REPOSITORIES[@]}"; do
        configure_apt_local_repository "$repository"
    done
}

configure_yum_local_repository() {
    local -r repo_name=$1 gpgcheck=${2:-0}
    local -r repo_path="$BASE_DIR/packages/redhat/$repo_name-el7"
    local gpg_keys

    gpg_keys=$(
        find "$repo_path" -maxdepth 1 -name "RPM-GPG-KEY-*" \
            -printf "file://%p "
    )

    cat > /etc/yum.repos.d/"$repo_name".repo << EOF
[$repo_name]
name=$repo_name
baseurl=file://$repo_path
enabled=1
gpgcheck=$gpgcheck
${gpg_keys:+gpgkey=${gpg_keys%?}}
EOF
}

configure_apt_local_repository() {
    local -r repo_name=$1
    local -r repo_path="$BASE_DIR/packages/debian/$repo_name"
    echo "deb [trusted=yes] file://$repo_path bionic $repo_name" \
        > /etc/apt/sources.list.d/"$repo_name".list
}

install_packages() {
    local -ra packages=("$@")
    local -a repo_list=(/etc/apt/sources.list)

    case "$OS" in
        centos|rhel)
            local -a yum_opts=(
                '--assumeyes'
            )
            "$YUM" install "${yum_opts[@]}" "${packages[@]}"
            ;;
        ubuntu)
            mapfile -O 1 -t repo_list < <(find \
                /etc/apt/sources.list.d/ \
                ! -name 'metalk8s-*' -a -name '*.list')

            for source_list in "${repo_list[@]}"; do
                mv "$source_list"{,.disabled}
            done
            "$APT" update
            DEBIAN_FRONTEND=noninteractive "$APT" -y install "${packages[@]}" \
                || exit_code=$?

            for source_list in "${repo_list[@]}"; do
                mv "$source_list"{.disabled,}
            done

            return ${exit_code:-0}
            ;;
        *)
            die "OS $OS not supported";;
    esac
}

configure_salt_minion_local_mode() {
    local -r file_root="$BASE_DIR/salt"

    "$SALT_CALL" --file-root="$file_root" \
        --local --retcode-passthrough saltutil.sync_all saltenv=base
    "$SALT_CALL" --file-root="$file_root" \
        --local --retcode-passthrough state.sls metalk8s.salt.minion.local \
        pillar="{'metalk8s': {'archives': '$BASE_DIR'}}" saltenv=base
}

get_salt_container() {
    local -r max_retries=10
    local salt_container='' attempts=0

    while [ -z "$salt_container" ] && [ $attempts -lt $max_retries ]; do
        salt_container="$(crictl ps -q \
            --label io.kubernetes.pod.namespace=kube-system \
            --label io.kubernetes.container.name=salt-master \
            --state Running)"
        (( attempts++ ))
    done

    if [ -z "$salt_container" ]; then
        echo "Failed to find a running 'salt-master' container" >&2
        exit 1
    fi

    echo "$salt_container"
}

orchestrate_bootstrap() {
    # Grains must be set (in `/etc/salt/grains`) *before* invoking `salt-call`,
    # otherwise grains set during execution won't be taken into account
    # properly.
    run "Calculating Salt grains in local mode" \
        "$SALT_CALL" --local --state-output=mixed --retcode-passthrough state.sls \
            metalk8s.node.grains \
            saltenv=metalk8s-@@VERSION \
            pillarenv=metalk8s-@@VERSION

    local -r control_plane_ip=$(
        $SALT_CALL --local grains.get metalk8s:control_plane_ip --out txt \
        | awk '/^local\: /{ print $2 }'
    )

    pillar=(
      "{"
      "  'repo': {'local_mode': True},"
      "  'metalk8s': {"
      "    'endpoints': {"
      "      'repositories': {"
      "         'ip': $control_plane_ip,"
      "         'ports': {'http': 8080}"
      "      },"
      "      'salt-master': {'ip': $control_plane_ip}"
      "    }"
      "  }"
      "}"
    )

    run "Deploying early-stage bootstrap node in local mode (this may take a while)" \
        "$SALT_CALL" --local --state-output=mixed --retcode-passthrough state.sls \
            '["metalk8s.kubernetes.ca.kubernetes.installed", "metalk8s.roles.bootstrap", "metalk8s.roles.minion"]' \
            saltenv=metalk8s-@@VERSION \
            pillarenv=metalk8s-@@VERSION \
            pillar="${pillar[*]}"

    SALT_MASTER_CALL=(crictl exec -i "$(get_salt_container)")

    run "Syncing Utility modules on Salt master" \
        "${SALT_MASTER_CALL[@]}" salt-run --state-output=mixed saltutil.sync_utils \
            saltenv=metalk8s-@@VERSION

    run "Syncing Pillar modules on Salt master" \
        "${SALT_MASTER_CALL[@]}" salt-run --state-output=mixed saltutil.sync_pillar \
            saltenv=metalk8s-@@VERSION
    run "Syncing Runner modules on Salt master" \
        "${SALT_MASTER_CALL[@]}" salt-run --state-output=mixed saltutil.sync_runners \
            saltenv=metalk8s-@@VERSION
    run "Syncing Execution modules on Salt master" \
        "${SALT_MASTER_CALL[@]}" salt-run --state-output=mixed saltutil.sync_modules \
            saltenv=metalk8s-@@VERSION

    local -r bootstrap_id=$(
        $SALT_CALL --local --out txt grains.get id \
        | awk '/^local\: /{ print $2 }'
    )

    pillar=(
      "{"
      "  'bootstrap_id': '$bootstrap_id'"
      "}"
    )

    run "Accepting bootstrap minion key on Salt master" \
        "${SALT_MASTER_CALL[@]}" salt-run --state-output=mixed state.orchestrate \
            metalk8s.orchestrate.bootstrap.accept-minion \
            saltenv=metalk8s-@@VERSION \
            pillar="${pillar[*]}"

    run "Refreshing all modules and data on bootstrap minion" \
        salt-call --state-output=mixed saltutil.sync_all \
            refresh=True \
            saltenv=metalk8s-@@VERSION

    run "Deploying bootstrap node (this may take a while)" \
        "${SALT_MASTER_CALL[@]}" salt-run --state-output=mixed state.orchestrate \
            metalk8s.orchestrate.bootstrap \
            saltenv=metalk8s-@@VERSION \
            pillar="${pillar[*]}"

    # The `mine.update` executed during `metalk8s.orchestrate.bootstrap` seems
    # not always to actually update the mine with all `mine_functions` we
    # expect. Forcing another update seems to resolve this somewhat.
    run "Syncing mine" \
        "$SALT_CALL" mine.update
}

main() {
    run "Determine the OS" determine_os
    run "Pre-minion system tests" pre_minion_checks
    run "Configure internal repositories" configure_repositories
    run "Disabling Salt minion service" disable_salt_minion_service
    run "Stopping Salt minion service" stop_salt_minion_service
    run "Configuring local repositories" configure_repositories
    run "Installing mandatory packages" install_packages "${PACKAGES[@]}"
    run "Configuring Salt minion to run in local mode" configure_salt_minion_local_mode

    orchestrate_bootstrap

    "$BASE_DIR"/backup.sh
}

main
